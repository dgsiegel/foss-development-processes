\chapter{Introduction} % {{{
\label{chap:introduction}

\section{Problem and Motivation} % {{{

Without \ac{FOSS} the modern daily grind would be unthinkable. They empower
\emph{Fortune 500} companies such as Google, Amazon, Red Hat or Facebook. They
also are key figures in the internet, running on most of the servers, but also
on smart phones or other devices. However \ac{FOSS} projects are not only
useful tools, there is also an active development community behind them which
consists of volunteers but also companies.

Lowdown such as the costs, the free availability of the source code and the
number of people who work on a single project are certainly positive aspects of
\ac{FOSS} projects. They allow to use them without big investments and risks to
implement an idea quickly and effectively. A matching example is the company
Google which used the Linux operating system to build big data centers
cost-effectively. That is just one of the many reasons why \ac{FOSS} has become
quite popular especially in the last years.

On account of the different origins and backgrounds of the single projects,
different development models have evolved, which look inimitable. Examples are
the different communities, development and release cycles, the used tools or
the project structure. When comparing them at first glance they indeed look
quite different, too diverse seem the different project leaders, the
communities and the goals of each project. The question here is now whether
projects have common grounds or use so called \emph{best practices}.

Unfortunately there are not too many scrutinies which aim for similarities or
differences in the development processes of \ac{FOSS} projects. There exist
however many studies about single aspects of projects, such as the motivation
of developers, the social structure inside a project, the communication,
development workflows or software engineering methods. This thesis should
provide a primary step into this direction, summarizing the findings and trying
to establish a common ground.

Concretely, this study wants to answer the following research question: How do
\ac{FOSS} projects work, which structures do they have and which workflows have
they established. To accomplish this, several \ac{FOSS} will be analyzed in
order to identify concertedly models. In addition they will be compared to
traditional software engineering models in order to see whether they are
similar or oppose differences.

% }}}

\section{Outline of the Thesis} % {{{

\paragraph{\autoref{chap:introduction} -- \nameref{chap:introduction}}

This chapter presents an overview of the thesis and introduces the reader to
the problem and motivation of this analysis.

\paragraph{\autoref{chap:theoretical background} -- \nameref{chap:theoretical background}}

In order to empower a scientific research for the project analysis, several
research methods and tools will be introduced in this chapter. Additionally
traditional and agile software engineering methods will be discussed.

\paragraph{\autoref{chap:related work} -- \nameref{chap:related work}}

An outline of related researches in the field of \ac{FOSS}, the development
processes, case studies and software engineering methods is presented with the
appropriate references.

\paragraph{\autoref{chap:methodology} -- \nameref{chap:methodology}}

The used methodology and explanations of visualized project data will be
provided in this chapter. This includes a general explanation of methods and
the presentation of collected data.

\paragraph{\autoref{chap:analysis} -- \nameref{chap:analysis}}

A deeper look is made at several \ac{FOSS} projects, coming up with an analysis
catalogue and applying that on further projects. This analysis will be the
center piece on which further chapters build on.

\paragraph{\autoref{chap:comparison} -- \nameref{chap:comparison}}

This chapter examines the previous made analysis and compares the found
findings by working through the previously established catalogue and analyses.

\paragraph{\autoref{chap:discussion} -- \nameref{chap:discussion}}

The findings will be evaluated, analyzed and compared with traditional software
engineering methods, related findings by other researchers and previously
explained methods.

\paragraph{\autoref{chap:conclusion} -- \nameref{chap:conclusion}}

The thesis finally concludes with a summary and draws together the main
findings of the study along with possible future directions.

% }}}

% }}}
