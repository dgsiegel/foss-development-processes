\chapter{Conclusion} % {{{
\label{chap:conclusion}

This work began with the problem and motivation of development processes in
\ac{FOSS} projects. It defined the main goal of the work, which was to analyze
the development workflows of \ac{FOSS} projects and to find matching patterns.

Next, the used theoretical background was explained and established. This
included research methods such as the grounded theory or the qualitative
content analysis. The usage of such methods was vindicated by similar research
papers and studies which also use the same or similar research methods. Also
traditional and agile software engineering methods were offered for later use.
As traditional software engineering methods the waterfall and spiral model were
explained. The instances of agile software engineering methods were the
\acl{XP} and Scrum software engineering models.

The methodology of how projects were chosen was defined. Based on that,
\ac{FOSS} projects were analyzed and categorized to find the matching projects.
The results were the \ac{FOSS} projects Debian, Drupal, Fedora, GNOME, KDE,
MySQL/MariaDB, PHP, Plone, PostgreSQL and Python. Next, automated gathering of
project data and the visualization thereof was discussed and explained. This
determined the further analysis and the constitution of the work.

Using the grounded theory research method, data about the projects was
collected and the chosen projects were analyzed in depth. Six projects were
examined most thoroughly to come up with a project analysis catalogue. So far
the grounded theory approach was used. The catalogue was then used to research
the other four projects with qualitative content analysis, as proposed earlier.

Finally the outcome of the previous project analysis was compared according to
the project analysis catalogue and differences or similarities between the
projects were distinguished. This included all development related parts of the
projects, such as the project origin, the community, communication and
structure of the project, the release process with it's schedules and cycles,
as well as the development process of each project with the general workflow,
development lead and feature inclusion process.

On this build the following discussion which took the results of the previous
comparison and checked against similar researches or studies. Most effort was
given to a comparison with other research findings and whether they were
similar or if the found results could disagree with them.

As mentioned before the most important finding was that the project analysis
catalogue was adequate for a development process analysis of the projects and
therefore the processes of the analyzed \ac{FOSS} project's aren't that
different after all. Of course, no project is equal to another one, but the
general processes could be found in one form or another in all projects.

Similarities start with the inception of the projects, which all started due to
personal motivation. This generally concords with other findings. An unexpected
result was the not present Bazaar model in all of the analyzed projects. Other
researchers came to the same conclusion, however the Bazaar model is closely
related to \ac{FOSS} projects and therefore one would anticipate them in most
of \ac{FOSS} projects. On the contrary, all projects had a very hierarchical
structure, even if they were very modular or had a quite flat structure. It has
to be noted however, that only the core parts of the projects were analyzed and
therefore, a Bazaar like model could still be found around the projects. This
was not analyzed in this thesis.

Despite the hierarchical structure of the projects, they are still very welcome
to new developers and often one can quickly step up the ladder and become a
member in a leading group in the project. In this facet the Bazaar model
still holds.

Furthermore there was a noticeable move towards fixed release cycles and more
generally to a already pre-defined release schedule. This is very surprising as
it is a widely spread opinion that \ac{FOSS} projects do release when
\emph{it's ready}. This still can be seen in several projects, such as Debian
or Drupal, however in both projects there is a strong opinion for fixed release
cycles and it should only be a matter of time until they implement them.

Similar to commercial projects all projects did have people or teams in place
to ensure the compliance with the release schedule. This finding is also
closely related to the previously noted hierarchical structure in the projects.

Another important finding is that the development processes of \ac{FOSS} are
similar between each other but cannot be resembled by traditional or agile
software engineering methods. The development processes all were very agile and
iterative. The outcome of this is obviously an evolutionary process in which
the product gets better with each cycle. There are only few cases known in
which the project restarted from scratch. As such the found processes and
development methods were quite different to the previously described software
engineering methods. Though several aspects of each proposed method could be
found in the engineering cycles.

Finally the finding by \textcite{Conway1968} could be corroborated and be
applied to the findings. It states that the organization of a software system
is similar to the group which designed and implemented the system. According to
the made findings this not only holds for the final product but also for the
development processes and workflows. The Python project should stand as a
primary example of a very organized and structured group which also established
a very formal and textured development process.

By no means this analysis can be considered as exhaustive, as the made findings
only hold for the chosen projects and there only for the core parts. As such,
it would be interesting to apply the project analysis catalogue to more
projects and look out for differences to the made findings. A further analysis
of such kind should of course establish different project selection criteria,
such as less or more mature projects, but also smaller or bigger projects than
the analyzed projects.

Furthermore this analysis did not have a strong focus on the motivation of
developers, the community or interaction thereof. An interesting study would be
to have a stronger focus on the mentioned categories and see how they empower
the different structures or workflows.

Also, as noted before, it seems that projects seem to evolve together with
their processes over time. This raises a number of questions for future
research such as if they evolve with a similar process or if there are similar
processes or workflows to be found at similar times.

While the initial findings are promising, further research is necessary. This
also includes the assets and drawbacks of fixed release cycles and why projects
tend to adopt them.

Concluding this section, the work presented in this thesis provides a
consistent framework for analysis and discussion of \ac{FOSS} projects. Ideally
it is able to describe processes adequately with a high focus on reusability
and integrity. \acl{FOSS} projects are essential tools in the modern
daily grind and we should be eager to see what else we can learn from
\acl{FOSS} development processes and projects.

% }}}
